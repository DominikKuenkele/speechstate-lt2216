{"version":3,"sources":["dmAppointment.ts","index.tsx"],"names":["say","text","send","_context","type","value","menuGrammar","description","patterns","titleGrammar","timeGrammar","dayGrammar","binaryGrammar","machineAnswers","abstractPromptMachine","prompt","initial","states","entry","context","on","ENDSPEECH","ask","nomatch","Math","random","length","getAssignActionFor","category","assigner","title","recResult","utterance","day","find","includes","time","regexExec","exec","undefined","ActionTypes","Assign","assignment","categoryPromptMachine","target","RECOGNISED","cond","test","verifyUtterance","actions","TIMEOUT","binaryPromptMachine","targetTrue","targetFalse","dmMachine","idle","CLICK","init","TTS_READY","getUsername","assign","username","welcome","some","regex","celebrityName","menuHelp","options","Object","values","forEach","substr","askForCelebrity","invoke","src","kbRequest","onDone","celebrityInfo","event","data","split","onError","infoCelebrity","meetingCelebrity","createMeeting","getTitle","getDay","wholeDay","getTime","confirmation","info","fetch","Request","then","json","cancel","REGION","inspect","url","iframe","machine","Machine","id","dm","asrtts","audioCtx","_ctx","window","AudioContext","webkitAudioContext","navigator","mediaDevices","getUserMedia","audio","stream","createMediaStreamSource","getToken","_evt","getAuthorizationToken","azureAuthorizationToken","ponyfillTTS","_event","callback","_onReceive","ponyfill","createSpeechSynthesisPonyfill","audioContext","credentials","region","authorizationToken","speechSynthesis","SpeechSynthesisUtterance","tts","ttsUtterance","addEventListener","voices","getVoices","voiceRe","RegExp","process","voice","v","name","console","error","TTS_ERROR","LISTEN","SPEAK","ttsAgenda","recognising","exit","ASRRESULT","SELECT","noinput","delay","tdmPassivity","STARTSPEECH","inprogress","match","pause","speaking","fail","recLogResult","log","logIntent","nluData","intent","ReactiveButton","props","promptText","state","tdmVisualOutputInfo","el","attribute","promptImage","circleClass","matches","className","alt","style","FigureButton","caption","alternative","imageSrc","App","useMachine","devTools","changeColour","asEffect","document","body","background","recStart","asr","start","recStop","abort","ttsStart","content","REACT_APP_TTS_LEXICON","debug","onend","speak","ttsStop","ponyfillASR","SpeechRecognition","createSpeechRecognitionPonyfill","lang","continuous","interimResults","onresult","result","results","isFinal","transcript","confidence","current","figureButtons","tdmExpectedAlternatives","filter","o","visual_information","map","i","onClick","semantic_expression","method","headers","rootElement","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.5748d6c4.chunk.js","sourcesContent":["import {Action, ActionTypes, assign, AssignAction, MachineConfig, PropertyAssigner, send,} from \"xstate\";\n\nfunction say(text: (context: SDSContext) => string): Action<SDSContext, any> {\n    return send((_context: SDSContext) => ({type: \"SPEAK\", value: text(_context)}))\n}\n\nconst menuGrammar: { [index: string]: { description: string, patterns: Array<RegExp> } } = {\n    \"meeting\": {\n        description: \"create a meeting\",\n        patterns: [\n            /Create a meeting./,\n            /I would like to schedule a meeting./\n        ]\n    },\n    \"whois\": {\n        description: \"request information about a person\",\n        patterns: [\n            /Who is (.*)\\?/,\n            /Tell me something about (.*)\\?/\n        ]\n    },\n    \"stop\": {\n        description: \"stop me\",\n        patterns: [\n            /Stop./,\n            /Shut up./\n        ]\n    },\n    \"options\": {\n        description: \"\",\n        patterns: [\n            /What can I do?/,\n            /How can you help me?/\n        ]\n    }\n}\n\nconst titleGrammar: { [index: string]: string } = {\n    \"Lecture.\": \"Dialogue systems lecture\",\n    \"Lunch.\": \"Lunch at the canteen\",\n    \"Training.\": \"Workout at the gym\",\n    \"Cinema.\": \"Watching a movie at the cinema\",\n    \"Shopping.\": \"Shopping in the city\",\n    \"Swedish course.\": \"Learning swedish\",\n    \"President.\": \"Talking to the president\",\n    \"Garden\": \"Walk in the garden\",\n    \"Sleeping\": \"Taking a nap\"\n}\n\nconst timeGrammar: RegExp = /(At )?(((1[0-2]|[1-9]):[0-5][0-9]|(1[0-2]|[1-9]))( [AP]M)?( o'clock)?\\.?)/\n\nconst dayGrammar: string[] = [\n    \"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\",\n    \"Today\",\n    \"Tomorrow\"\n]\n\nconst binaryGrammar: { [index: string]: Array<string> } = {\n    \"Yes\": [\"Yes.\", \"Of course.\", \"Sure.\", \"Yeah.\", \"Yes please.\", \"Yep.\", \"OK.\", \"Yes, thank you.\"],\n    \"No\": [\"No.\", \"Nope.\", \"No no.\", \"Don't.\", \"Don't do it.\", \"No way.\", \"Not at all.\"]\n}\n\nconst machineAnswers: { [index: string]: Array<string> } = {\n    \"CR\": [\n        \"Sorry, could you please repeat that?\",\n        \"I didn't catch that?\",\n        \"What did you say?\",\n        \"Come again?\",\n        \"Sorry?\",\n        \"Huh?\"\n    ]\n}\n\nfunction abstractPromptMachine(prompt: (context: SDSContext) => string): MachineConfig<SDSContext, any, SDSEvent> {\n    return {\n        initial: 'prompt',\n        states: {\n            prompt: {\n                entry: say(context => prompt(context)),\n                on: {ENDSPEECH: 'ask'}\n            },\n            ask: {\n                entry: send('LISTEN'),\n            },\n            nomatch: {\n                entry: say(() => machineAnswers[\"CR\"][Math.random() * machineAnswers[\"CR\"].length | 0]),\n                on: {ENDSPEECH: 'ask'}\n            }\n        }\n    }\n}\n\nfunction verifyUtterance(utterance: string, category: string): boolean {\n    switch (category) {\n        case \"title\":\n            return utterance in titleGrammar\n        case \"day\":\n            for (const day of dayGrammar) {\n                if (utterance.includes(day)) {\n                    return true;\n                }\n            }\n            return false;\n        case \"time\":\n            return timeGrammar.test(utterance)\n        default:\n            return false;\n    }\n}\n\nfunction getAssignActionFor(category: string): AssignAction<SDSContext, any> {\n    let assigner: PropertyAssigner<SDSContext, any>;\n    switch (category) {\n        case \"title\":\n            assigner = {title: (context) => titleGrammar[context.recResult[0].utterance]};\n            break;\n        case \"day\":\n            assigner = {day: (context) => dayGrammar.find(day => context.recResult[0].utterance.includes(day))!};\n            break;\n        case \"time\":\n            assigner = {\n                time: (context) => {\n                    let regexExec = timeGrammar.exec(context.recResult[0].utterance)!;\n                    // use number/time and add AM/PM if existing\n                    return regexExec[3] + (regexExec[6] !== undefined ? regexExec[6] : \"\")\n                }\n            }\n            break;\n        default:\n            assigner = {}\n    }\n    return {\n        type: ActionTypes.Assign,\n        assignment: assigner\n    }\n}\n\nfunction categoryPromptMachine(prompt: (context: SDSContext) => string, category: string, target: string): MachineConfig<SDSContext, any, SDSEvent> {\n    return {\n        ...abstractPromptMachine(prompt),\n        on: {\n            RECOGNISED: [\n                {\n                    target: target,\n                    cond: (context) => verifyUtterance(context.recResult[0].utterance, category),\n                    actions: {...getAssignActionFor(category)}\n                },\n                {\n                    target: '.nomatch'\n                }\n            ],\n            TIMEOUT: '.prompt'\n        }\n    };\n}\n\nfunction binaryPromptMachine(prompt: (context: SDSContext) => string, targetTrue: string, targetFalse: string): MachineConfig<SDSContext, any, SDSEvent> {\n    return {\n        ...abstractPromptMachine(prompt),\n        on: {\n            RECOGNISED: [\n                {\n                    target: targetTrue,\n                    cond: (context) => binaryGrammar[\"Yes\"].includes(context.recResult[0].utterance)\n                },\n                {\n                    target: targetFalse,\n                    cond: (context) => binaryGrammar[\"No\"].includes(context.recResult[0].utterance)\n                },\n                {\n                    target: '.nomatch'\n                }\n            ],\n            TIMEOUT: '.prompt'\n        }\n    };\n}\n\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'idle',\n    states: {\n        idle: {\n            on: {\n                CLICK: 'init'\n            }\n        },\n        init: {\n            on: {\n                TTS_READY: 'getUsername',\n                CLICK: 'getUsername'\n            }\n        },\n        getUsername: {\n            ...abstractPromptMachine(() => 'Hi, who are you?'),\n            on: {\n                RECOGNISED: [\n                    {\n                        target: 'welcome',\n                        cond: context => context.recResult[0].utterance === \"I don't want to be known.\"\n                    },\n                    {\n                        target: 'welcome',\n                        actions: assign({\n                            username: context => context.recResult[0].utterance\n                        })\n                    }\n                ],\n                TIMEOUT: '.prompt'\n            }\n        },\n        welcome: {\n            ...abstractPromptMachine(\n                (context) => `How can I help you, ${context.username !== undefined ? context.username : 'Anonymous'}!`\n            ),\n            on: {\n                RECOGNISED: [\n                    {\n                        target: 'createMeeting',\n                        cond: context => menuGrammar[\"meeting\"][\"patterns\"].some((regex) => regex.test(context.recResult[0].utterance))\n                    },\n                    {\n                        target: 'askForCelebrity',\n                        cond: context => menuGrammar[\"whois\"][\"patterns\"].some((regex) => regex.test(context.recResult[0].utterance)),\n                        actions: assign({\n                            celebrityName:\n                                context => {\n                                    for (let pattern of menuGrammar[\"whois\"][\"patterns\"]) {\n                                        let regexExec = pattern.exec(context.recResult[0].utterance)!;\n                                        if (regexExec !== null && regexExec[1] !== undefined) {\n                                            return regexExec[1]\n                                        }\n                                    }\n                                    //will never happen, since cond verifies it already before\n                                    return \"\"\n                                }\n                        })\n                    },\n                    {\n                        target: 'menuHelp',\n                        cond: context => menuGrammar[\"options\"][\"patterns\"].some((regex) => regex.test(context.recResult[0].utterance))\n                    },\n                    {\n                        target: 'init',\n                        cond: context => menuGrammar[\"stop\"][\"patterns\"].some((regex) => regex.test(context.recResult[0].utterance))\n                    },\n                    {\n                        target: '.nomatch'\n                    }\n                ],\n                TIMEOUT: '.prompt'\n            }\n        },\n        menuHelp: {\n            entry: say(() => {\n                let options = \"You can \"\n                Object.values(menuGrammar).forEach((value) =>\n                    value[\"description\"] != \"\" ? options += value[\"description\"] + \" or \" : \"\")\n                return options.substr(0, options.length - 4) + \".\"\n            }),\n            on: {\n                ENDSPEECH: \"welcome.ask\"\n            }\n        },\n        askForCelebrity: {\n            invoke: {\n                src: context => kbRequest(context.celebrityName),\n                onDone: {\n                    target: 'infoCelebrity',\n                    // get only the first sentence of the Abstract\n                    actions: assign({celebrityInfo: (context, event) => event.data[\"Abstract\"].split(/\\. [A-Z]/)[0]})\n                },\n                onError: {\n                    target: 'meetingCelebrity',\n                    actions: say(context => `Sorry, I didn't get any info about ${context.celebrityName}`)\n                }\n            }\n        },\n        infoCelebrity: {\n            entry: say(context =>\n                context.celebrityInfo !== \"\"\n                    ? context.celebrityInfo\n                    : `I couldn't find any info about ${context.celebrityName}!`),\n            on: {\n                ENDSPEECH: {\n                    target: 'meetingCelebrity',\n                    actions: assign({\n                        title: context => `Meeting with ${context.celebrityName}`\n                    })\n                }\n            }\n        },\n        meetingCelebrity: {\n            ...binaryPromptMachine(() => \"Do you want to meet them?\", 'getDay', 'welcome')\n        },\n        createMeeting: {\n            entry: say(() => \"Let's create a meeting.\"),\n            on: {\n                ENDSPEECH: 'getTitle'\n            }\n        },\n        getTitle: {\n            ...categoryPromptMachine(() => \"What is it about?\", \"title\", 'getDay'),\n        },\n        getDay: {\n            ...categoryPromptMachine(() => \"On which day is it?\", \"day\", 'wholeDay'),\n        },\n        wholeDay: {\n            ...binaryPromptMachine(() => 'Will it take the whole day?', 'confirmation', 'getTime')\n        },\n        getTime: {\n            ...categoryPromptMachine(() => \"What time is your meeting?\", \"time\", 'confirmation'),\n        },\n        confirmation: {\n            ...binaryPromptMachine(\n                (context) =>\n                    `Do you want me to create a meeting titled ${context.title} on ${context.day} `\n                    + `${context.time !== undefined ? `at ${context.time}` : `for the whole day`}?`,\n                'info',\n                'welcome')\n        },\n        info: {\n            entry: say(() => \"Your meeting has been created!\"),\n            on: {ENDSPEECH: 'welcome'}\n        }\n    }\n})\n\n\nconst kbRequest = (text: string) =>\n    fetch(new Request(`https://cors.eu.org/https://api.duckduckgo.com/?q=${text}&format=json&skip_disambig=1`)).then(data => data.json())\n","import \"./styles.scss\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { Machine, assign, actions, State } from \"xstate\";\nimport { useMachine, asEffect } from \"@xstate/react\";\nimport { inspect } from \"@xstate/inspect\";\nimport { dmMachine } from \"./dmAppointment\";\n\nimport createSpeechRecognitionPonyfill from 'web-speech-cognitive-services/lib/SpeechServices/SpeechToText'\nimport createSpeechSynthesisPonyfill from 'web-speech-cognitive-services/lib/SpeechServices/TextToSpeech';\n\n\nconst { send, cancel } = actions\n\nconst TOKEN_ENDPOINT = 'https://northeurope.api.cognitive.microsoft.com/sts/v1.0/issuetoken';\nconst REGION = 'northeurope';\n\ninspect({\n    url: \"https://statecharts.io/inspect\",\n    iframe: false\n});\n\n\nconst defaultPassivity = 10\n\nconst machine = Machine<SDSContext, any, SDSEvent>({\n    id: 'root',\n    type: 'parallel',\n    states: {\n        dm: {\n            ...dmMachine\n        },\n\n        asrtts: {\n            initial: 'init',\n            states: {\n                init: {\n                    on: {\n                        CLICK: {\n                            target: 'getToken',\n                            actions: [\n                                assign({\n                                    audioCtx: (_ctx) =>\n                                        new ((window as any).AudioContext || (window as any).webkitAudioContext)()\n                                }),\n                                (context) =>\n                                    navigator.mediaDevices.getUserMedia({ audio: true })\n                                        .then(function(stream) { context.audioCtx.createMediaStreamSource(stream) })\n                            ]\n                        }\n                    }\n                },\n                getToken: {\n                    invoke: {\n                        id: \"getAuthorizationToken\",\n                        src: (_ctx, _evt) => getAuthorizationToken(),\n                        onDone: {\n                            actions: [\n                                assign((_context, event) => { return { azureAuthorizationToken: event.data } }),\n                                'ponyfillASR'],\n                            target: 'ponyfillTTS'\n                        },\n                        onError: {\n                            target: 'fail'\n                        }\n                    }\n                },\n                ponyfillTTS: {\n                    invoke: {\n                        id: 'ponyTTS',\n                        src: (context, _event) => (callback, _onReceive) => {\n                            const ponyfill = createSpeechSynthesisPonyfill({\n                                audioContext: context.audioCtx,\n                                credentials: {\n                                    region: REGION,\n                                    authorizationToken: context.azureAuthorizationToken,\n                                }\n                            });\n                            const { speechSynthesis, SpeechSynthesisUtterance } = ponyfill;\n                            context.tts = speechSynthesis\n                            context.ttsUtterance = SpeechSynthesisUtterance\n                            context.tts.addEventListener('voiceschanged', () => {\n                                context.tts.cancel()\n                                const voices = context.tts.getVoices();\n                                let voiceRe = RegExp(\"en-US\", 'u')\n                                if (process.env.REACT_APP_TTS_VOICE) {\n                                    voiceRe = RegExp(process.env.REACT_APP_TTS_VOICE, 'u')\n                                }\n                                const voice = voices.find((v: any) => voiceRe.test(v.name))!\n                                if (voice) {\n                                    context.voice = voice\n                                    callback('TTS_READY')\n                                } else {\n                                    console.error(`TTS_ERROR: Could not get voice for regexp ${voiceRe}`)\n                                    callback('TTS_ERROR')\n                                }\n                            })\n                        }\n                    },\n                    on: {\n                        TTS_READY: 'idle',\n                        TTS_ERROR: 'fail'\n                    }\n                },\n                idle: {\n                    on: {\n                        LISTEN: 'recognising',\n                        SPEAK: {\n                            target: 'speaking',\n                            actions: assign((_context, event) => { return { ttsAgenda: event.value } })\n                        }\n                    },\n                },\n                recognising: {\n                    initial: 'noinput',\n                    exit: 'recStop',\n                    on: {\n                        ASRRESULT: {\n                            actions: ['recLogResult',\n                                assign((_context, event) => {\n                                    return {\n                                        recResult: event.value\n                                    }\n                                })],\n                            target: '.match'\n                        },\n                        RECOGNISED: 'idle',\n                        SELECT: 'idle',\n                        CLICK: '.pause'\n                    },\n                    states: {\n                        noinput: {\n                            entry: [\n                                'recStart',\n                                send(\n                                    { type: 'TIMEOUT' },\n                                    { delay: (context) => (1000 * (context.tdmPassivity || defaultPassivity)), id: 'timeout' }\n                                )],\n                            on: {\n                                TIMEOUT: '#root.asrtts.idle',\n                                STARTSPEECH: 'inprogress'\n                            },\n                            exit: cancel('timeout')\n                        },\n                        inprogress: {\n                        },\n                        match: {\n                            entry: send('RECOGNISED'),\n                        },\n                        pause: {\n                            entry: 'recStop',\n                            on: { CLICK: 'noinput' }\n                        }\n                    }\n                },\n                speaking: {\n                    entry: 'ttsStart',\n                    on: {\n                        ENDSPEECH: 'idle',\n                        SELECT: 'idle',\n                        CLICK: { target: 'idle', actions: send('ENDSPEECH') }\n                    },\n                    exit: 'ttsStop',\n                },\n                fail: {}\n            }\n        }\n    },\n},\n    {\n        actions: {\n            recLogResult: (context: SDSContext) => {\n                /* context.recResult = event.recResult; */\n                console.log('U>', context.recResult[0][\"utterance\"], context.recResult[0][\"confidence\"]);\n            },\n            logIntent: (context: SDSContext) => {\n                /* context.nluData = event.data */\n                console.log('<< NLU intent: ' + context.nluData.intent.name)\n            }\n        },\n    });\n\n\n\ninterface Props extends React.HTMLAttributes<HTMLElement> {\n    state: State<SDSContext, any, any, any>;\n    alternative: any;\n}\nconst ReactiveButton = (props: Props): JSX.Element => {\n    var promptText = ((props.state.context.tdmVisualOutputInfo || [{}])\n        .find((el: any) => el.attribute === \"name\") || {}).value;\n    var promptImage = ((props.state.context.tdmVisualOutputInfo || [{}])\n        .find((el: any) => el.attribute === \"image\") || {}).value;\n    var circleClass = \"circle\"\n    switch (true) {\n        case props.state.matches({ asrtts: 'fail' }) || props.state.matches({ dm: 'fail' }):\n            break;\n        case props.state.matches({ asrtts: { recognising: 'pause' } }):\n            promptText = \"Click to continue\"\n            break;\n        case props.state.matches({ asrtts: 'recognising' }):\n            circleClass = \"circle-recognising\"\n            promptText = promptText || 'Listening...'\n            break;\n        case props.state.matches({ asrtts: 'speaking' }):\n            circleClass = \"circle-speaking\"\n            promptText = promptText || 'Speaking...'\n            break;\n        case props.state.matches({ dm: 'idle' }):\n            promptText = \"Click to start!\"\n            circleClass = \"circle-click\"\n            break;\n        case props.state.matches({ dm: 'init' }):\n            promptText = \"Click to start!\"\n            circleClass = \"circle-click\"\n            break;\n        default:\n            promptText = promptText || '\\u00A0'\n    }\n    return (\n        <div className=\"control\">\n            <figure className=\"prompt\">\n                {promptImage &&\n                    <img src={promptImage}\n                        alt={promptText} />}\n            </figure>\n            <div className=\"status\">\n                <button type=\"button\" className={circleClass}\n                    style={{}} {...props}>\n                </button>\n                <div className=\"status-text\">\n                    {promptText}\n                </div>\n            </div>\n        </div>);\n}\n\nconst FigureButton = (props: Props): JSX.Element => {\n    const caption = props.alternative.find((el: any) => el.attribute === \"name\").value\n    const imageSrc = (props.alternative.find((el: any) => el.attribute === \"image\") || {}).value\n    return (\n        <figure className=\"flex\" {...props}>\n            {imageSrc &&\n                <img src={imageSrc} alt={caption} />}\n            <figcaption>{caption}</figcaption>\n        </figure>\n    )\n}\n\nfunction App() {\n    const [current, send] = useMachine(machine, {\n        devTools: true,\n        actions: {\n\n            changeColour: asEffect((context) => {\n                document.body.style.background = context.recResult[0].utterance;\n                /* console.log('Ready to receive a voice input.'); */\n            }),\n\n            recStart: asEffect((context) => {\n                context.asr.start()\n                /* console.log('Ready to receive a voice input.'); */\n            }),\n            recStop: asEffect((context) => {\n                context.asr.abort()\n                /* console.log('Recognition stopped.'); */\n            }),\n            ttsStart: asEffect((context) => {\n                let content = `<speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\" xmlns:mstts=\"http://www.w3.org/2001/mstts\" xml:lang=\"en-US\"><voice name=\"${context.voice.name}\">`\n                content = content + (process.env.REACT_APP_TTS_LEXICON ? `<lexicon uri=\"${process.env.REACT_APP_TTS_LEXICON}\"/>` : \"\")\n                content = content + `${context.ttsAgenda}</voice></speak>`\n                console.debug(content)\n                const utterance = new context.ttsUtterance(content);\n                console.log(\"S>\", context.ttsAgenda)\n                utterance.voice = context.voice\n                utterance.onend = () => send('ENDSPEECH')\n                context.tts.speak(utterance)\n            }),\n            ttsStop: asEffect((context) => {\n                /* console.log('TTS STOP...'); */\n                context.tts.cancel()\n            }),\n            ponyfillASR: asEffect((context, _event) => {\n                const\n                    { SpeechRecognition }\n                        = createSpeechRecognitionPonyfill({\n                            audioContext: context.audioCtx,\n                            credentials: {\n                                region: REGION,\n                                authorizationToken: context.azureAuthorizationToken,\n                            }\n                        });\n                context.asr = new SpeechRecognition()\n                context.asr.lang = process.env.REACT_APP_ASR_LANGUAGE || 'en-US'\n                context.asr.continuous = true\n                context.asr.interimResults = true\n                context.asr.onresult = function(event: any) {\n                    var result = event.results[0]\n                    if (result.isFinal) {\n                        send({\n                            type: \"ASRRESULT\", value:\n                                [{\n                                    \"utterance\": result[0].transcript,\n                                    \"confidence\": result[0].confidence\n                                }]\n                        })\n                    } else {\n                        send({ type: \"STARTSPEECH\" });\n                    }\n                }\n\n            })\n        }\n    });\n    const figureButtons = (current.context.tdmExpectedAlternatives || []).filter((o: any) => o.visual_information)\n        .map(\n            (o: any, i: any) => (\n                <FigureButton state={current}\n                    alternative={o.visual_information}\n                    key={i}\n                    onClick={() => send({ type: 'SELECT', value: o.semantic_expression })} />\n            )\n        )\n\n    switch (true) {\n        default:\n            return (\n                <div className=\"App\">\n                    <ReactiveButton state={current} alternative={{}} onClick={() => send('CLICK')} />\n                    <div className=\"select-wrapper\">\n                        <div className=\"select\">\n                            {figureButtons}\n                        </div>\n                    </div>\n                </div>\n            )\n    }\n\n};\n\nconst getAuthorizationToken = () => (\n    fetch(new Request(TOKEN_ENDPOINT, {\n        method: 'POST',\n        headers: {\n            'Ocp-Apim-Subscription-Key': process.env.REACT_APP_SUBSCRIPTION_KEY!\n        },\n    })).then(data => data.text()))\n\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n    <App />,\n    rootElement);\n"],"sourceRoot":""}