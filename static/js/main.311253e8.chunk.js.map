{"version":3,"sources":["dmAppointmentPlus.ts","index.tsx"],"names":["say","text","send","_context","type","value","menuGrammar","description","patterns","titleGrammar","timeGrammar","dayGrammar","binaryGrammar","machineAnswers","helpGrammar","getPrompts","prompt","state","hist","number","entry","on","ENDSPEECH","target","HIST","parseInt","length","abstractPromptMachine","initial","states","verification","ask","RECOGNISED","cond","context","includes","recResult","utterance","listen","getAssignActionFor","category","assigner","title","day","find","time","regexExec","exec","undefined","ActionTypes","Assign","assignment","categoryPromptMachine","test","verifyUtterance","actions","TIMEOUT","binaryPromptMachine","targetTrue","targetFalse","dmMachine","some","regex","idle","CLICK","init","TTS_READY","help","nomatch","Math","random","dialogue","history","getUsername","assign","username","welcome","celebrityName","menuHelp","options","Object","values","forEach","substr","homeAssistant","invokeRasa","invoke","src","nluRequest","onDone","_","event","data","onError","vacuum","always","moveToTrash","give","turnOnLight","turnOffLight","cook","askOvenWarm","responses","informOvenWarm","askForCelebrity","kbRequest","celebrityInfo","split","infoCelebrity","meetingCelebrity","createMeeting","getTitle","getDay","wholeDay","getTime","confirmation","info","fetch","Request","method","body","then","json","cancel","REGION","inspect","url","iframe","machine","Machine","id","dm","asrtts","audioCtx","_ctx","window","AudioContext","webkitAudioContext","navigator","mediaDevices","getUserMedia","audio","stream","createMediaStreamSource","getToken","_evt","getAuthorizationToken","azureAuthorizationToken","ponyfillTTS","_event","callback","_onReceive","ponyfill","createSpeechSynthesisPonyfill","audioContext","credentials","region","authorizationToken","speechSynthesis","SpeechSynthesisUtterance","tts","ttsUtterance","addEventListener","voices","getVoices","voiceRe","RegExp","process","voice","v","name","console","error","TTS_ERROR","LISTEN","SPEAK","ttsAgenda","recognising","exit","ASRRESULT","SELECT","RECSTOP","noinput","delay","tdmPassivity","STARTSPEECH","inprogress","match","pause","speaking","fail","recLogResult","log","logIntent","nluData","intent","ReactiveButton","props","promptText","tdmVisualOutputInfo","el","attribute","promptImage","circleClass","matches","className","alt","style","FigureButton","caption","alternative","imageSrc","App","useMachine","devTools","changeColour","asEffect","document","background","recStart","asr","start","recStop","abort","ttsStart","content","debug","onend","speak","ttsStop","ponyfillASR","SpeechRecognition","createSpeechRecognitionPonyfill","lang","continuous","interimResults","onresult","result","results","isFinal","transcript","confidence","current","figureButtons","tdmExpectedAlternatives","filter","o","visual_information","map","i","onClick","semantic_expression","headers","rootElement","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.311253e8.chunk.js","sourcesContent":["import {Action, ActionTypes, assign, AssignAction, MachineConfig, PropertyAssigner, send, StatesConfig,} from \"xstate\";\n\nfunction say(text: (context: SDSContext) => string): Action<SDSContext, any> {\n    return send((_context: SDSContext) => ({type: \"SPEAK\", value: text(_context)}))\n}\n\nconst menuGrammar: { [index: string]: { description: string, patterns: Array<RegExp> } } = {\n    \"meeting\": {\n        description: \"create a meeting\",\n        patterns: [\n            /Create a meeting./,\n            /I would like to schedule a meeting./\n        ]\n    },\n    \"whois\": {\n        description: \"request information about a person\",\n        patterns: [\n            /Who is (.*)\\?/,\n            /Tell me something about (.*)\\?/\n        ]\n    },\n    \"stop\": {\n        description: \"stop me\",\n        patterns: [\n            /Stop./,\n            /Shut up./\n        ]\n    },\n    \"homeAssistant\": {\n        description: \"ask me for home assistance\",\n        patterns: [\n            /Can you help me with home assistance/,\n            /Assist me in my home/\n        ]\n    },\n    \"options\": {\n        description: \"\",\n        patterns: [\n            /What can I do?/,\n            /How can you help me?/\n        ]\n    }\n};\n\nconst titleGrammar: { [index: string]: string } = {\n    \"Lecture.\": \"Dialogue systems lecture\",\n    \"Lunch.\": \"Lunch at the canteen\",\n    \"Training.\": \"Workout at the gym\",\n    \"Cinema.\": \"Watching a movie at the cinema\",\n    \"Shopping.\": \"Shopping in the city\",\n    \"Swedish course.\": \"Learning swedish\",\n    \"President.\": \"Talking to the president\",\n    \"Garden\": \"Walk in the garden\",\n    \"Sleeping\": \"Taking a nap\"\n};\n\nconst timeGrammar: RegExp = /(At )?(((1[0-2]|[1-9]):[0-5][0-9]|(1[0-2]|[1-9]))( [AP]M)?( o'clock)?\\.?)/;\n\nconst dayGrammar: string[] = [\n    \"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\",\n    \"Today\",\n    \"Tomorrow\"\n];\n\nconst binaryGrammar: { [index: string]: Array<string> } = {\n    \"Yes\": [\"Yes.\", \"Of course.\", \"Sure.\", \"Yeah.\", \"Yes please.\", \"Yep.\", \"OK.\", \"Yes, thank you.\"],\n    \"No\": [\"No.\", \"Nope.\", \"No no.\", \"Don't.\", \"Don't do it.\", \"No way.\", \"Not at all.\"]\n};\n\nconst machineAnswers: { [index: string]: Array<string> } = {\n    \"CR\": [\n        \"Sorry, could you please repeat that?\",\n        \"I didn't catch that?\",\n        \"What did you say?\",\n        \"Come again?\",\n        \"Sorry?\",\n        \"Huh?\"\n    ]\n};\n\nconst helpGrammar: RegExp[] = [\n    /Help./\n];\n\nfunction getPrompts(prompt: ((context: SDSContext) => string)[]): StatesConfig<SDSContext, any, SDSEvent> {\n    let state: StatesConfig<SDSContext, any, SDSEvent> = {\n        hist: {\n            type: 'history'\n        }\n    };\n\n    for (let number in prompt) {\n        state = {\n            ...state,\n            ['prompt' + number]: {\n                entry: say(prompt[number]),\n                on: {\n                    ENDSPEECH: {\n                        target: 'ask' + number,\n                    }\n\n                }\n            },\n            ['ask' + number]: {\n                entry: send('LISTEN'),\n                on: {\n                    HIST: {\n                        target: parseInt(number) + 1 < prompt.length ? 'prompt' + (parseInt(number) + 1) : '#root.dm.init'\n                    }\n                }\n            }\n        }\n    }\n    return state;\n}\n\n\nfunction abstractPromptMachine(prompt: ((context: SDSContext) => string)[]): MachineConfig<SDSContext, any, SDSEvent> {\n    return {\n        initial: 'prompt0',\n        states: {\n            ...getPrompts(prompt),\n            verification: {\n                states:{\n                    ask: {\n                        entry: say(() => 'verification'),\n                        //@ts-ignore\n                        on: {\n                            RECOGNISED: [\n                                {\n                                    target: {value: 'as'},\n                                    cond: (context) => binaryGrammar[\"Yes\"].includes(context.recResult[0].utterance)\n                                },\n                                {\n                                    target: 'prompt0',\n                                    cond: (context) => binaryGrammar[\"No\"].includes(context.recResult[0].utterance)\n                                }\n                            ],\n                        }\n                    },\n                    listen: {\n\n                    }\n                }\n\n            }\n        }\n    }\n}\n\nfunction verifyUtterance(utterance: string, category: string): boolean {\n    switch (category) {\n        case \"title\":\n            return utterance in titleGrammar\n        case \"day\":\n            for (const day of dayGrammar) {\n                if (utterance.includes(day)) {\n                    return true;\n                }\n            }\n            return false;\n        case \"time\":\n            return timeGrammar.test(utterance)\n        default:\n            return false;\n    }\n}\n\nfunction getAssignActionFor(category: string): AssignAction<SDSContext, any> {\n    let assigner: PropertyAssigner<SDSContext, any>;\n    switch (category) {\n        case \"title\":\n            assigner = {title: (context) => titleGrammar[context.recResult[0].utterance]};\n            break;\n        case \"day\":\n            assigner = {day: (context) => dayGrammar.find(day => context.recResult[0].utterance.includes(day))!};\n            break;\n        case \"time\":\n            assigner = {\n                time: (context) => {\n                    let regexExec = timeGrammar.exec(context.recResult[0].utterance)!;\n                    // use number/time and add AM/PM if existing\n                    return regexExec[3] + (regexExec[6] !== undefined ? regexExec[6] : \"\")\n                }\n            }\n            break;\n        default:\n            assigner = {}\n    }\n    return {\n        type: ActionTypes.Assign,\n        assignment: assigner\n    }\n}\n\nfunction categoryPromptMachine(prompt: ((context: SDSContext) => string)[], category: string, target: string): MachineConfig<SDSContext, any, SDSEvent> {\n    return {\n        ...abstractPromptMachine(prompt),\n        on: {\n            RECOGNISED: [\n                {\n                    target: target,\n                    cond: (context) => verifyUtterance(context.recResult[0].utterance, category),\n                    actions: {...getAssignActionFor(category)}\n                }\n            ],\n            TIMEOUT: {\n                target: '.hist',\n                actions: send('HIST')\n            }\n        }\n    };\n}\n\nfunction binaryPromptMachine(prompt: ((context: SDSContext) => string)[], targetTrue: string, targetFalse: string): MachineConfig<SDSContext, any, SDSEvent> {\n    return {\n        ...abstractPromptMachine(prompt),\n        on: {\n            RECOGNISED: [\n                {\n                    target: targetTrue,\n                    cond: (context) => binaryGrammar[\"Yes\"].includes(context.recResult[0].utterance)\n                },\n                {\n                    target: targetFalse,\n                    cond: (context) => binaryGrammar[\"No\"].includes(context.recResult[0].utterance)\n                }\n            ],\n            TIMEOUT: {\n                target: '.hist',\n                actions: send('HIST')\n            }\n        }\n    };\n}\n\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'idle',\n    on: {\n        RECOGNISED: [\n            {\n                target: '.help',\n                cond: context => helpGrammar.some((regex) => regex.test(context.recResult[0].utterance))\n            },\n            {\n                target: '.nomatch'\n            }\n        ]\n    },\n    states: {\n        idle: {\n            on: {\n                CLICK: 'init'\n            }\n        },\n        init: {\n            on: {\n                TTS_READY: 'dialogue',\n                CLICK: 'dialogue'\n            }\n        },\n        help: {\n            entry: say(() => 'I can help you to create meetings in your calendar'),\n            on: {\n                ENDSPEECH: 'dialogue.hist'\n            }\n        },\n        nomatch: {\n            entry: say(() => machineAnswers[\"CR\"][Math.random() * machineAnswers[\"CR\"].length | 0]),\n            on: {\n                ENDSPEECH: 'dialogue.hist'\n            }\n        },\n        dialogue: {\n            initial: 'getUsername',\n            states: {\n                hist: {\n                    type: 'history',\n                    history: 'deep'\n                },\n                getUsername: {\n                    ...abstractPromptMachine([\n                        () => 'Hi, who are you?',\n                        () => 'What is your name?',\n                        () => 'Hello?']),\n                    on: {\n                        RECOGNISED: [\n                            {\n                                target: 'welcome',\n                                cond: context => context.recResult[0].utterance === \"I don't want to be known.\"\n                            },\n                            {\n                                target: 'welcome',\n                                actions: assign({\n                                    username: context => context.recResult[0].utterance\n                                })\n                            }\n                        ],\n                        TIMEOUT: {\n                            target: '.hist',\n                            actions: send('HIST')\n                        }\n                    }\n                },\n                welcome: {\n                    ...abstractPromptMachine(\n                        [\n                            (context) => `How can I help you, ${context.username !== undefined ? context.username : 'Anonymous'}!`,\n                            () => 'What can I do for you?',\n                            (context) => `${context.username !== undefined ? context.username : 'Hello'}?`\n                        ]\n                    ),\n                    on: {\n                        RECOGNISED: [\n                            {\n                                target: 'createMeeting',\n                                cond: context => menuGrammar[\"meeting\"][\"patterns\"].some((regex) => regex.test(context.recResult[0].utterance))\n                            },\n                            {\n                                target: 'askForCelebrity',\n                                cond: context => menuGrammar[\"whois\"][\"patterns\"].some((regex) => regex.test(context.recResult[0].utterance)),\n                                actions: assign({\n                                    celebrityName:\n                                        context => {\n                                            for (let pattern of menuGrammar[\"whois\"][\"patterns\"]) {\n                                                let regexExec = pattern.exec(context.recResult[0].utterance)!;\n                                                if (regexExec !== null && regexExec[1] !== undefined) {\n                                                    return regexExec[1]\n                                                }\n                                            }\n                                            //will never happen, since cond verifies it already before\n                                            return \"\"\n                                        }\n                                })\n                            },\n                            {\n                                target: 'homeAssistant',\n                                cond: context => menuGrammar[\"homeAssistant\"][\"patterns\"].some((regex) => regex.test(context.recResult[0].utterance))\n                            },\n                            {\n                                target: 'menuHelp',\n                                cond: context => menuGrammar[\"options\"][\"patterns\"].some((regex) => regex.test(context.recResult[0].utterance))\n                            },\n                            {\n                                target: '#root.dm.init',\n                                cond: context => menuGrammar[\"stop\"][\"patterns\"].some((regex) => regex.test(context.recResult[0].utterance))\n                            }\n                        ],\n                        TIMEOUT: {\n                            target: '.hist',\n                            actions: send('HIST')\n                        }\n                    }\n                },\n                menuHelp: {\n                    entry: say(() => {\n                        let options = \"You can \"\n                        Object.values(menuGrammar).forEach((value) =>\n                            value[\"description\"] !== \"\" ? options += value[\"description\"] + \" or \" : \"\")\n                        return options.substr(0, options.length - 4) + \".\"\n                    }),\n                    on: {\n                        ENDSPEECH: \"welcome.hist\"\n                    }\n                },\n                homeAssistant: {\n                    initial: 'ask',\n                    states: {\n                        ask: {\n                            ...abstractPromptMachine(\n                                [\n                                    () => 'How can I assist you?',\n                                    () => 'How may I help you?',\n                                    (context) => `${context.username}?`\n                                ]),\n                            on: {\n                                RECOGNISED: 'invokeRasa',\n                                TIMEOUT: {\n                                    target: '.hist',\n                                    actions: send('HIST')\n                                }\n                            }\n                        },\n                        invokeRasa: {\n                            invoke: {\n                                src: context => nluRequest(context.recResult[0].utterance),\n                                onDone: [\n                                    {\n                                        cond: (_, event) => event.data['intent']['name'] === 'vacuum',\n                                        target: 'vacuum'\n                                    },\n                                    {\n                                        cond: (_, event) => event.data['intent']['name'] === 'move_to_trash',\n                                        target: 'moveToTrash'\n                                    },\n                                    {\n                                        cond: (_, event) => event.data['intent']['name'] === 'give',\n                                        target: 'give'\n                                    },\n                                    {\n                                        cond: (_, event) => event.data['intent']['name'] === 'turn_on_light',\n                                        target: 'turnOnLight'\n                                    },\n                                    {\n                                        cond: (_, event) => event.data['intent']['name'] === 'turn_off_light',\n                                        target: 'turnOffLight'\n                                    },\n                                    {\n                                        cond: (_, event) => event.data['intent']['name'] === 'cook',\n                                        target: 'cook'\n                                    },\n                                    {\n                                        cond: (_, event) => event.data['intent']['name'] === 'ask_oven_warm',\n                                        target: 'askOvenWarm'\n                                    },\n                                    {\n                                        cond: (_, event) => event.data['intent']['name'] === 'inform_oven_warm',\n                                        target: 'informOvenWarm'\n                                    }\n                                ],\n                                onError: 'ask.hist'\n                            }\n                        },\n                        vacuum: {\n                            entry: say(() => 'I will clean the floor.'),\n                            always: 'ask'\n                        },\n                        moveToTrash: {\n                            entry: say(() => 'I will throw it into the trash.'),\n                            always: 'ask'\n                        },\n                        give: {\n                            entry: say(() => 'I will give it to them.'),\n                            always: 'ask'\n                        },\n                        turnOnLight: {\n                            entry: say(() => \"I'll turn off the light.\"),\n                            always: 'ask'\n                        },\n                        turnOffLight: {\n                            entry: say(() => 'I will turn on the light.'),\n                            always: 'ask'\n                        },\n                        cook: {\n                            entry: say(() => 'I will prepare the meal.'),\n                            always: 'ask'\n                        },\n                        askOvenWarm: {\n                            entry: say(() => {\n                                let responses = ['The oven is warm.', 'The oven is cold.'];\n                                return responses[Math.random() * responses.length | 0]\n                            }),\n                            always: 'ask'\n                        },\n                        informOvenWarm: {\n                            entry: say(() => 'Ok, thanks.'),\n                            always: 'ask'\n                        }\n                    }\n                },\n                askForCelebrity: {\n                    invoke: {\n                        src: context => kbRequest(context.celebrityName),\n                        onDone: {\n                            target: 'infoCelebrity',\n                            // get only the first sentence of the Abstract\n                            actions: assign({celebrityInfo: (context, event) => event.data[\"Abstract\"].split(/\\. [A-Z]/)[0]})\n                        },\n                        onError: {\n                            target: 'meetingCelebrity',\n                            actions: say(context => `Sorry, I didn't get any info about ${context.celebrityName}`)\n                        }\n                    }\n                },\n                infoCelebrity: {\n                    entry: say(context =>\n                        context.celebrityInfo !== \"\"\n                            ? context.celebrityInfo\n                            : `I couldn't find any info about ${context.celebrityName}!`),\n                    on: {\n                        ENDSPEECH: {\n                            target: 'meetingCelebrity',\n                            actions: assign({\n                                title: context => `Meeting with ${context.celebrityName}`\n                            })\n                        }\n                    }\n                },\n                meetingCelebrity: {\n                    ...binaryPromptMachine([\n                        () => \"Do you want to meet them?\",\n                        () => \"Shall I create a meeting?\",\n                        (context) => `${context.username}?`\n                    ], 'getDay', 'welcome')\n                },\n                createMeeting: {\n                    entry: say(() => \"Let's create a meeting.\"),\n                    on: {\n                        ENDSPEECH: 'getTitle'\n                    }\n                },\n                getTitle: {\n                    ...categoryPromptMachine([\n                        () => \"What is it about?\",\n                        () => \"How should I call the meeting?\",\n                        () => \"What is the purpose?\"\n                    ], \"title\", 'getDay'),\n                },\n                getDay: {\n                    ...categoryPromptMachine([\n                        () => \"On which day is it?\",\n                        () => \"Which day?\",\n                        (context) => `${context.username}?`\n                    ], \"day\", 'wholeDay'),\n                },\n                wholeDay: {\n                    ...binaryPromptMachine([\n                        () => 'Will it take the whole day?',\n                        () => 'For the whole day?',\n                        () => 'Is it the whole day?'\n                    ], 'confirmation', 'getTime')\n                },\n                getTime: {\n                    ...categoryPromptMachine([\n                        () => \"What time is your meeting?\",\n                        () => \"At which time?\",\n                        () => \"When should is start?\"\n                    ], \"time\", 'confirmation'),\n                },\n                confirmation: {\n                    ...binaryPromptMachine(\n                        [(context) =>\n                            `Do you want me to create a meeting titled ${context.title} on ${context.day} `\n                            + `${context.time !== undefined ? `at ${context.time}` : `for the whole day`}?`],\n                        'info',\n                        'welcome')\n                },\n                info: {\n                    entry: say(() => \"Your meeting has been created!\"),\n                    on: {ENDSPEECH: 'welcome'}\n                }\n            }\n        }\n    }\n})\n\nconst rasaurl = 'https://rasa-nlu-api-00.herokuapp.com/model/parse';\nconst nluRequest = (text: string) =>\n    fetch(new Request(rasaurl, {\n        method: 'POST',\n        body: `{\"text\": \"${text}\"}`\n    }))\n        .then(data => data.json());\n\nconst kbRequest = (text: string) =>\n    fetch(new Request(`https://cors.eu.org/https://api.duckduckgo.com/?q=${text}&format=json&skip_disambig=1`)).then(data => data.json())\n","import \"./styles.scss\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport {Machine, assign, actions, State} from \"xstate\";\nimport {useMachine, asEffect} from \"@xstate/react\";\nimport {inspect} from \"@xstate/inspect\";\nimport {dmMachine} from \"./dmAppointmentPlus\";\n\nimport createSpeechRecognitionPonyfill from 'web-speech-cognitive-services/lib/SpeechServices/SpeechToText'\nimport createSpeechSynthesisPonyfill from 'web-speech-cognitive-services/lib/SpeechServices/TextToSpeech';\n\n\nconst {send, cancel} = actions\n\nconst TOKEN_ENDPOINT = 'https://northeurope.api.cognitive.microsoft.com/sts/v1.0/issuetoken';\nconst REGION = 'northeurope';\n\ninspect({\n    url: \"https://statecharts.io/inspect\",\n    iframe: false\n});\n\n\nconst defaultPassivity = 3\n\nconst machine = Machine<SDSContext, any, SDSEvent>({\n        id: 'root',\n        type: 'parallel',\n        states: {\n            dm: {\n                ...dmMachine\n            },\n\n            asrtts: {\n                initial: 'init',\n                states: {\n                    init: {\n                        on: {\n                            CLICK: {\n                                target: 'getToken',\n                                actions: [\n                                    assign({\n                                        audioCtx: (_ctx) =>\n                                            new ((window as any).AudioContext || (window as any).webkitAudioContext)()\n                                    }),\n                                    (context) =>\n                                        navigator.mediaDevices.getUserMedia({audio: true})\n                                            .then(function (stream) {\n                                                context.audioCtx.createMediaStreamSource(stream)\n                                            })\n                                ]\n                            }\n                        }\n                    },\n                    getToken: {\n                        invoke: {\n                            id: \"getAuthorizationToken\",\n                            src: (_ctx, _evt) => getAuthorizationToken(),\n                            onDone: {\n                                actions: [\n                                    assign((_context, event) => {\n                                        return {azureAuthorizationToken: event.data}\n                                    }),\n                                    'ponyfillASR'],\n                                target: 'ponyfillTTS'\n                            },\n                            onError: {\n                                target: 'fail'\n                            }\n                        }\n                    },\n                    ponyfillTTS: {\n                        invoke: {\n                            id: 'ponyTTS',\n                            src: (context, _event) => (callback, _onReceive) => {\n                                const ponyfill = createSpeechSynthesisPonyfill({\n                                    audioContext: context.audioCtx,\n                                    credentials: {\n                                        region: REGION,\n                                        authorizationToken: context.azureAuthorizationToken,\n                                    }\n                                });\n                                const {speechSynthesis, SpeechSynthesisUtterance} = ponyfill;\n                                context.tts = speechSynthesis\n                                context.ttsUtterance = SpeechSynthesisUtterance\n                                context.tts.addEventListener('voiceschanged', () => {\n                                    context.tts.cancel()\n                                    const voices = context.tts.getVoices();\n                                    let voiceRe = RegExp(\"en-US\", 'u')\n                                    if (process.env.REACT_APP_TTS_VOICE) {\n                                        voiceRe = RegExp(process.env.REACT_APP_TTS_VOICE, 'u')\n                                    }\n                                    const voice = voices.find((v: any) => voiceRe.test(v.name))!\n                                    if (voice) {\n                                        context.voice = voice\n                                        callback('TTS_READY')\n                                    } else {\n                                        console.error(`TTS_ERROR: Could not get voice for regexp ${voiceRe}`)\n                                        callback('TTS_ERROR')\n                                    }\n                                })\n                            }\n                        },\n                        on: {\n                            TTS_READY: 'idle',\n                            TTS_ERROR: 'fail'\n                        }\n                    },\n                    idle: {\n                        on: {\n                            LISTEN: 'recognising',\n                            SPEAK: {\n                                target: 'speaking',\n                                actions: assign((_context, event) => {\n                                    return {ttsAgenda: event.value}\n                                })\n                            }\n                        },\n                    },\n                    recognising: {\n                        initial: 'noinput',\n                        exit: 'recStop',\n                        on: {\n                            ASRRESULT: {\n                                actions: ['recLogResult',\n                                    assign((_context, event) => {\n                                        return {\n                                            recResult: event.value\n                                        }\n                                    })],\n                                target: '.match'\n                            },\n                            RECOGNISED: 'idle',\n                            SELECT: 'idle',\n                            CLICK: '.pause',\n                            RECSTOP: 'idle'\n                        },\n                        states: {\n                            noinput: {\n                                entry: [\n                                    'recStart',\n                                    send(\n                                        {type: 'TIMEOUT'},\n                                        {\n                                            delay: (context) => (1000 * (context.tdmPassivity || defaultPassivity)),\n                                            id: 'timeout'\n                                        }\n                                    )],\n                                on: {\n                                    TIMEOUT: '#root.asrtts.idle',\n                                    STARTSPEECH: 'inprogress'\n                                },\n                                exit: cancel('timeout')\n                            },\n                            inprogress: {},\n                            match: {\n                                entry: send('RECOGNISED'),\n                            },\n                            pause: {\n                                entry: 'recStop',\n                                on: {CLICK: 'noinput'}\n                            }\n                        }\n                    },\n                    speaking: {\n                        entry: 'ttsStart',\n                        on: {\n                            ENDSPEECH: 'idle',\n                            SELECT: 'idle',\n                            CLICK: {target: 'idle', actions: send('ENDSPEECH')}\n                        },\n                        exit: 'ttsStop',\n                    },\n                    fail: {}\n                }\n            }\n        },\n    },\n    {\n        actions: {\n            recLogResult: (context: SDSContext) => {\n                /* context.recResult = event.recResult; */\n                console.log('U>', context.recResult[0][\"utterance\"], context.recResult[0][\"confidence\"]);\n            },\n            logIntent: (context: SDSContext) => {\n                /* context.nluData = event.data */\n                console.log('<< NLU intent: ' + context.nluData.intent.name)\n            }\n        },\n    });\n\n\ninterface Props extends React.HTMLAttributes<HTMLElement> {\n    state: State<SDSContext, any, any, any>;\n    alternative: any;\n}\n\nconst ReactiveButton = (props: Props): JSX.Element => {\n    var promptText = ((props.state.context.tdmVisualOutputInfo || [{}])\n        .find((el: any) => el.attribute === \"name\") || {}).value;\n    var promptImage = ((props.state.context.tdmVisualOutputInfo || [{}])\n        .find((el: any) => el.attribute === \"image\") || {}).value;\n    var circleClass = \"circle\"\n    switch (true) {\n        case props.state.matches({asrtts: 'fail'}) || props.state.matches({dm: 'fail'}):\n            break;\n        case props.state.matches({asrtts: {recognising: 'pause'}}):\n            promptText = \"Click to continue\"\n            break;\n        case props.state.matches({asrtts: 'recognising'}):\n            circleClass = \"circle-recognising\"\n            promptText = promptText || 'Listening...'\n            break;\n        case props.state.matches({asrtts: 'speaking'}):\n            circleClass = \"circle-speaking\"\n            promptText = promptText || 'Speaking...'\n            break;\n        case props.state.matches({dm: 'idle'}):\n            promptText = \"Click to start!\"\n            circleClass = \"circle-click\"\n            break;\n        case props.state.matches({dm: 'init'}):\n            promptText = \"Click to start!\"\n            circleClass = \"circle-click\"\n            break;\n        default:\n            promptText = promptText || '\\u00A0'\n    }\n    return (\n        <div className=\"control\">\n            <figure className=\"prompt\">\n                {promptImage &&\n                    <img src={promptImage}\n                         alt={promptText}/>}\n            </figure>\n            <div className=\"status\">\n                <button type=\"button\" className={circleClass}\n                        style={{}} {...props}>\n                </button>\n                <div className=\"status-text\">\n                    {promptText}\n                </div>\n            </div>\n        </div>);\n}\n\nconst FigureButton = (props: Props): JSX.Element => {\n    const caption = props.alternative.find((el: any) => el.attribute === \"name\").value\n    const imageSrc = (props.alternative.find((el: any) => el.attribute === \"image\") || {}).value\n    return (\n        <figure className=\"flex\" {...props}>\n            {imageSrc &&\n                <img src={imageSrc} alt={caption}/>}\n            <figcaption>{caption}</figcaption>\n        </figure>\n    )\n}\n\nfunction App() {\n    const [current, send] = useMachine(machine, {\n        devTools: true,\n        actions: {\n\n            changeColour: asEffect((context) => {\n                document.body.style.background = context.recResult[0].utterance;\n                /* console.log('Ready to receive a voice input.'); */\n            }),\n\n            recStart: asEffect((context) => {\n                context.asr.start()\n                /* console.log('Ready to receive a voice input.'); */\n            }),\n            recStop: asEffect((context) => {\n                context.asr.abort()\n                /* console.log('Recognition stopped.'); */\n            }),\n            ttsStart: asEffect((context) => {\n                let content = `<speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\" xmlns:mstts=\"http://www.w3.org/2001/mstts\" xml:lang=\"en-US\"><voice name=\"${context.voice.name}\">`\n                content = content + (process.env.REACT_APP_TTS_LEXICON ? `<lexicon uri=\"${process.env.REACT_APP_TTS_LEXICON}\"/>` : \"\")\n                content = content + `${context.ttsAgenda}</voice></speak>`\n                console.debug(content)\n                const utterance = new context.ttsUtterance(content);\n                console.log(\"S>\", context.ttsAgenda)\n                utterance.voice = context.voice\n                utterance.onend = () => send('ENDSPEECH')\n                context.tts.speak(utterance)\n            }),\n            ttsStop: asEffect((context) => {\n                /* console.log('TTS STOP...'); */\n                context.tts.cancel()\n            }),\n            ponyfillASR: asEffect((context, _event) => {\n                const\n                    {SpeechRecognition}\n                        = createSpeechRecognitionPonyfill({\n                        audioContext: context.audioCtx,\n                        credentials: {\n                            region: REGION,\n                            authorizationToken: context.azureAuthorizationToken,\n                        }\n                    });\n                context.asr = new SpeechRecognition()\n                context.asr.lang = process.env.REACT_APP_ASR_LANGUAGE || 'en-US'\n                context.asr.continuous = true\n                context.asr.interimResults = true\n                context.asr.onresult = function (event: any) {\n                    var result = event.results[0]\n                    if (result.isFinal) {\n                        send({\n                            type: \"ASRRESULT\", value:\n                                [{\n                                    \"utterance\": result[0].transcript,\n                                    \"confidence\": result[0].confidence\n                                }]\n                        })\n                    } else {\n                        send({type: \"STARTSPEECH\"});\n                    }\n                }\n\n            })\n        }\n    });\n    const figureButtons = (current.context.tdmExpectedAlternatives || []).filter((o: any) => o.visual_information)\n        .map(\n            (o: any, i: any) => (\n                <FigureButton state={current}\n                              alternative={o.visual_information}\n                              key={i}\n                              onClick={() => send({type: 'SELECT', value: o.semantic_expression})}/>\n            )\n        )\n\n    switch (true) {\n        default:\n            return (\n                <div className=\"App\">\n                    <ReactiveButton state={current} alternative={{}} onClick={() => send('CLICK')}/>\n                    <div className=\"select-wrapper\">\n                        <div className=\"select\">\n                            {figureButtons}\n                        </div>\n                    </div>\n                </div>\n            )\n    }\n\n};\n\nconst getAuthorizationToken = () => (\n    fetch(new Request(TOKEN_ENDPOINT, {\n        method: 'POST',\n        headers: {\n            'Ocp-Apim-Subscription-Key': process.env.REACT_APP_SUBSCRIPTION_KEY!\n        },\n    })).then(data => data.text()))\n\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n    <App/>,\n    rootElement);\n"],"sourceRoot":""}